<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Crawl Prompt Web Scraper</title>
  <link
    href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css"
    rel="stylesheet"
  />
  <style>
    body {
      background-color: #f8f9fa;
    }
    .container {
      margin-top: 50px;
      max-width: 900px;
    }
    #scrape-message {
      margin-top: 20px;
    }
    #scrape-results {
      margin-top: 20px;
    }
    table {
      width: 100%;
      border-collapse: collapse;
      margin-bottom: 1rem;
    }
    th,
    td {
      padding: 8px;
      border: 1px solid #ddd;
    }
    .pagination-controls {
      margin-top: 20px;
    }
  </style>
</head>
<body>
  <div class="container">
    <h1 class="mb-4">Crawl Prompt Web Scraper</h1>
    <form id="scrapeForm">
      <div class="mb-3">
        <label for="scrape-url" class="form-label">Website URL</label>
        <input
          type="url"
          class="form-control"
          id="scrape-url"
          placeholder="Enter website URL"
          required
        />
      </div>
      <div class="mb-3">
        <label for="scrape-prompt" class="form-label">Prompt (What to extract?)</label>
        <textarea
          class="form-control"
          id="scrape-prompt"
          rows="3"
          placeholder="E.g., What do you need from the webpage?"
          required
        ></textarea>
      </div>
      <button type="submit" class="btn btn-primary">Scrape &amp; Show Results</button>
    </form>

    <div id="scrape-message"></div>

    <!-- This container will show the table for the current chunk -->
    <div id="scrape-results"></div>

    <!-- Pagination controls -->
    <div class="pagination-controls" id="pagination-controls" style="display:none;">
      <button id="prevBtn" class="btn btn-secondary">Previous</button>
      <span id="pageIndicator" class="mx-3"></span>
      <button id="nextBtn" class="btn btn-secondary">Next</button>
    </div>

    <button id="downloadBtn" class="btn btn-success mt-3" style="display:none;">
      Download CSV (Current Page)
    </button>
  </div>

  <script>
    let chunkData = [];   // Each entry is an array of objects (table data for a chunk)
    let currentPage = 0;  // Index of the current chunk/page

    document.getElementById("scrapeForm").addEventListener("submit", async function (e) {
      e.preventDefault();
      const url = document.getElementById("scrape-url").value;
      const prompt = document.getElementById("scrape-prompt").value;
      const messageDiv = document.getElementById("scrape-message");
      const resultsDiv = document.getElementById("scrape-results");
      const paginationDiv = document.getElementById("pagination-controls");
      const downloadBtn = document.getElementById("downloadBtn");
      const pageIndicator = document.getElementById("pageIndicator");

      // Reset UI
      messageDiv.innerHTML = "";
      resultsDiv.innerHTML = "";
      paginationDiv.style.display = "none";
      downloadBtn.style.display = "none";
      chunkData = [];
      currentPage = 0;

      // Show progress messages (one every 5 seconds)
      const progressMessages = [
        "Scraping website...",
        "Finding relevant information...",
        "Locating pagination...",
        "Processing data..."
      ];
      const finalMessage = "Scraping in progress, it might take a minute for accurate Information";
      let progressIndex = 0;
      let progressTimeout;

      function showNextMessage() {
        if (progressIndex < progressMessages.length) {
          messageDiv.innerHTML = `<div class="alert alert-info">${progressMessages[progressIndex]}</div>`;
          progressIndex++;
          progressTimeout = setTimeout(showNextMessage, 5000);
        } else {
          messageDiv.innerHTML = `<div class="alert alert-info">${finalMessage}</div>`;
        }
      }
      showNextMessage();

      try {
        // Send the POST request (front-end sends only URL and prompt)
        const response = await fetch("https://scraper.storieswhiletravelling.com/scrape", {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({ url, prompt })
        });

        clearTimeout(progressTimeout);
        messageDiv.innerHTML = '<div class="alert alert-info">Processing results...</div>';

        if (!response.ok) {
          throw new Error("Server error: " + response.statusText);
        }

        const data = await response.json();
        if (data.results && data.results.length > 0) {
          messageDiv.innerHTML = '<div class="alert alert-success">Results loaded successfully!</div>';

          // For each chunk received, clean it up and parse into an array of objects
          data.results.forEach((chunkStr) => {
            // Remove potential markdown fences (```json ... ```)
            chunkStr = chunkStr.replace(/```json\s*/i, "").replace(/```/g, "").trim();
            let parsed;
            try {
              parsed = JSON.parse(chunkStr);
            } catch (err) {
              parsed = { raw: chunkStr };
            }
            const arr = findMainArray(parsed);
            chunkData.push(arr);
          });

          // Display the first chunk
          showChunk(0);
          paginationDiv.style.display = chunkData.length > 1 ? "block" : "none";
          downloadBtn.style.display = "block";
          pageIndicator.textContent = `Page 1 of ${chunkData.length}`;
        } else {
          messageDiv.innerHTML = '<div class="alert alert-warning">No relevant data found.</div>';
        }
      } catch (error) {
        clearTimeout(progressTimeout);
        messageDiv.innerHTML = `<div class="alert alert-danger">Error: ${error.message}</div>`;
        console.error("Error:", error);
      }
    });

    // Pagination: handle Previous and Next buttons
    document.getElementById("prevBtn").addEventListener("click", function () {
      if (currentPage > 0) {
        showChunk(currentPage - 1);
      }
    });
    document.getElementById("nextBtn").addEventListener("click", function () {
      if (currentPage < chunkData.length - 1) {
        showChunk(currentPage + 1);
      }
    });

    // CSV Download for current page
    document.getElementById("downloadBtn").addEventListener("click", function () {
      if (chunkData.length === 0) return;
      const arr = chunkData[currentPage];
      const csvContent = buildCsv(arr);
      const blob = new Blob([csvContent], { type: "text/csv;charset=utf-8;" });
      const downloadUrl = URL.createObjectURL(blob);
      const a = document.createElement("a");
      a.href = downloadUrl;
      a.download = `scraped_data_page_${currentPage + 1}.csv`;
      document.body.appendChild(a);
      a.click();
      document.body.removeChild(a);
    });

    // Display chunk number pageIndex as table
    function showChunk(pageIndex) {
      currentPage = pageIndex;
      const resultsDiv = document.getElementById("scrape-results");
      const pageIndicator = document.getElementById("pageIndicator");
      resultsDiv.innerHTML = "";

      const arr = chunkData[pageIndex];
      if (!arr || arr.length === 0) {
        resultsDiv.innerHTML = "<div class='alert alert-warning'>No data for this chunk.</div>";
      } else {
        resultsDiv.innerHTML = buildTableHtml(arr);
      }
      pageIndicator.textContent = `Page ${pageIndex + 1} of ${chunkData.length}`;
    }

    // Attempt to extract the "main" array of objects from the parsed data.
    // 1) If data is an array of objects, return it.
    // 2) If data is an object with one key which is an array of objects, return that array.
    // 3) Otherwise, wrap the entire data in an array.
    function findMainArray(data) {
      if (Array.isArray(data) && data.every(isPlainObject)) {
        return data;
      }
      if (isPlainObject(data)) {
        const keys = Object.keys(data);
        if (keys.length === 1 && Array.isArray(data[keys[0]])) {
          const arr = data[keys[0]];
          if (arr.every(isPlainObject)) {
            return arr;
          }
        }
      }
      return [typeof data === "object" ? data : { value: String(data) }];
    }

    // Check if an item is a plain object.
    function isPlainObject(item) {
      return item && typeof item === "object" && !Array.isArray(item) &&
        Object.prototype.toString.call(item) === "[object Object]";
    }

    // Build an HTML table from an array of objects.
    // For non-array object fields, the cell spans multiple rows.
    function buildTableHtml(dataArray) {
      if (!dataArray || dataArray.length === 0) {
        return "<div class='alert alert-warning'>No data to display.</div>";
      }
      // Gather all keys from each object.
      const allKeys = new Set();
      dataArray.forEach(obj => {
        Object.keys(obj).forEach(k => allKeys.add(k));
      });
      const keys = Array.from(allKeys);

      let html = "<table class='table table-striped'><thead><tr>";
      keys.forEach(key => {
        html += `<th>${key}</th>`;
      });
      html += "</tr></thead><tbody>";

      dataArray.forEach(obj => {
        // Determine the maximum number of rows required for this object (if some fields are arrays)
        const rowCounts = keys.map(key => {
          const val = obj[key];
          return Array.isArray(val) ? val.length : 1;
        });
        const maxRows = Math.max(...rowCounts);

        // Build rows for this object
        for (let rowIndex = 0; rowIndex < maxRows; rowIndex++) {
          html += "<tr>";
          keys.forEach(key => {
            let val = obj[key] !== undefined ? obj[key] : "";
            if (Array.isArray(val)) {
              // For array values, pick the item for the current row
              val = rowIndex < val.length ? val[rowIndex] : "";
            } else if (typeof val === "object") {
              val = JSON.stringify(val, null, 2);
            }

            // If the field is not an array, display it only once with rowspan
            if (!Array.isArray(obj[key])) {
              if (rowIndex === 0) {
                html += `<td rowspan="${maxRows}">${val}</td>`;
              }
            } else {
              html += `<td>${val}</td>`;
            }
          });
          html += "</tr>";
        }
      });

      html += "</tbody></table>";
      return html;
    }

    // Build CSV content from an array of objects.
    function buildCsv(dataArray) {
      if (!dataArray || dataArray.length === 0) return "";
      const allKeys = new Set();
      dataArray.forEach(obj => {
        Object.keys(obj).forEach(k => allKeys.add(k));
      });
      const keys = Array.from(allKeys);

      let csv = keys.join(",") + "\n";
      dataArray.forEach(obj => {
        const row = keys.map(key => {
          let val = obj[key] !== undefined ? obj[key] : "";
          if (typeof val === "object") {
            val = JSON.stringify(val);
          }
          val = String(val).replace(/"/g, '""');
          return `"${val}"`;
        }).join(",");
        csv += row + "\n";
      });
      return csv;
    }
  </script>
</body>
</html>
